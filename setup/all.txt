import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

final themeModeProvider = StateProvider<ThemeMode>((ref) => ThemeMode.light);

class AppTheme {
  // Base colors
  static const Color primaryColor = Color(0xFF008080);
  static const Color secondaryColor = Color(0xFF4DB6AC);
  static const Color accentColor = Color(0xFFFFA000);

  static const Color errorColor = Color(0xFFD32F2F);
  static const Color darkErrorColor = Color(0xFFCF6679);

  static const Color surfaceLight = Colors.white;
  static const Color surfaceDark = Color(0xFF1C1D1F);

  static const Color backgroundLight = Color(0xFFF5F5F5);
  static const Color backgroundDark = Color(0xFF121212);

  static const Color onPrimaryLight = Colors.white;
  static const Color onPrimaryDark = Colors.white;

  static const Color onSecondaryLight = Colors.black;
  static const Color onSecondaryDark = Colors.black;

  static const Color onSurfaceLight = Color(0xFF333333);
  static const Color onSurfaceDark = Color(0xFFE0E0E0);

  static const Color onBackgroundLight = Color(0xFF333333);
  static const Color onBackgroundDark = Color(0xFFE0E0E0);

  static const Color onErrorLight = Colors.white;
  static const Color onErrorDark = Colors.black;

  static const double cardRadius = 16.0;
  static const double buttonRadius = 12.0;
  static const double inputRadius = 12.0;

  static OutlineInputBorder _border(Color color) => OutlineInputBorder(
        borderRadius: BorderRadius.circular(inputRadius),
        borderSide: BorderSide(width: 1.5, color: color),
      );

  static ThemeData lightTheme = ThemeData.light().copyWith(
    useMaterial3: true,
    colorScheme: const ColorScheme(
      brightness: Brightness.light,
      primary: primaryColor,
      onPrimary: onPrimaryLight,
      secondary: secondaryColor,
      onSecondary: onSecondaryLight,
      surface: surfaceLight,
      onSurface: onSurfaceLight,
      background: backgroundLight,
      onBackground: onBackgroundLight,
      error: errorColor,
      onError: onErrorLight,
    ),
    scaffoldBackgroundColor: backgroundLight,
    visualDensity: VisualDensity.adaptivePlatformDensity,
    textTheme: GoogleFonts.poppinsTextTheme().apply(
      bodyColor: onSurfaceLight,
      displayColor: onSurfaceLight,
    ),
    inputDecorationTheme: InputDecorationTheme(
      filled: true,
      fillColor: Colors.white,
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      enabledBorder: _border(const Color(0xFFE0E0E0)),
      focusedBorder: _border(primaryColor),
      errorBorder: _border(errorColor),
      focusedErrorBorder: _border(errorColor),
      labelStyle: const TextStyle(color: Color(0xFF616161)),
      hintStyle: const TextStyle(color: Color(0xFF9E9E9E)),
    ),
    appBarTheme: AppBarTheme(
      backgroundColor: surfaceLight,
      elevation: 1,
      centerTitle: true,
      titleTextStyle: GoogleFonts.poppins(
        color: onSurfaceLight,
        fontSize: 20,
        fontWeight: FontWeight.w600,
      ),
      iconTheme: const IconThemeData(color: onSurfaceLight),
    ),
    cardTheme: CardTheme(
      elevation: 1,
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(cardRadius),
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: primaryColor,
        foregroundColor: onPrimaryLight,
        padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 24),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(buttonRadius),
        ),
        textStyle: GoogleFonts.poppins(
          fontWeight: FontWeight.w600,
          fontSize: 16,
        ),
      ),
    ),
    outlinedButtonTheme: OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        foregroundColor: primaryColor,
        side: const BorderSide(color: primaryColor),
        padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 24),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(buttonRadius),
        ),
        textStyle: GoogleFonts.poppins(
          fontWeight: FontWeight.w600,
          fontSize: 16,
        ),
      ),
    ),
    bottomNavigationBarTheme: BottomNavigationBarThemeData(
      backgroundColor: surfaceLight,
      selectedItemColor: primaryColor,
      unselectedItemColor: const Color(0xFF9E9E9E),
      elevation: 4,
      type: BottomNavigationBarType.fixed,
      selectedLabelStyle: GoogleFonts.poppins(fontSize: 12),
      unselectedLabelStyle: GoogleFonts.poppins(fontSize: 12),
    ),
    chipTheme: ChipThemeData(
      backgroundColor: const Color(0xFFE0E0E0),
      selectedColor: primaryColor,
      secondarySelectedColor: primaryColor,
      labelStyle: GoogleFonts.poppins(color: Colors.black),
      secondaryLabelStyle: GoogleFonts.poppins(color: Colors.white),
      padding: const EdgeInsets.symmetric(horizontal: 12),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
      ),
    ),
  );

  static ThemeData darkTheme = ThemeData.dark().copyWith(
    useMaterial3: true,
    colorScheme: const ColorScheme(
      brightness: Brightness.dark,
      primary: primaryColor,
      onPrimary: onPrimaryDark,
      secondary: secondaryColor,
      onSecondary: onSecondaryDark,
      surface: surfaceDark,
      onSurface: onSurfaceDark,
      background: backgroundDark,
      onBackground: onBackgroundDark,
      error: darkErrorColor,
      onError: onErrorDark,
    ),
    scaffoldBackgroundColor: backgroundDark,
    visualDensity: VisualDensity.adaptivePlatformDensity,
    textTheme: GoogleFonts.poppinsTextTheme().apply(
      bodyColor: onSurfaceDark,
      displayColor: onSurfaceDark,
    ),
    inputDecorationTheme: InputDecorationTheme(
      filled: true,
      fillColor: const Color(0xFF1E1E1E),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      enabledBorder: _border(const Color(0xFF424242)),
      focusedBorder: _border(primaryColor),
      errorBorder: _border(darkErrorColor),
      focusedErrorBorder: _border(darkErrorColor),
      labelStyle: const TextStyle(color: Color(0xFFB0B0B0)),
      hintStyle: const TextStyle(color: Color(0xFF757575)),
    ),
    appBarTheme: AppBarTheme(
      backgroundColor: surfaceDark,
      surfaceTintColor: Colors.transparent,
      elevation: 0,
      centerTitle: true,
      titleTextStyle: GoogleFonts.poppins(
        color: onSurfaceDark,
        fontSize: 20,
        fontWeight: FontWeight.w600,
      ),
      iconTheme: const IconThemeData(color: Colors.white),
    ),
    cardTheme: CardTheme(
      elevation: 2,
      margin: EdgeInsets.zero,
      color: const Color(0xFF1E1E1E),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(cardRadius),
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: primaryColor,
        foregroundColor: onPrimaryDark,
        padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 24),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(buttonRadius),
        ),
        textStyle: GoogleFonts.poppins(
          fontWeight: FontWeight.w600,
          fontSize: 16,
        ),
      ),
    ),
    outlinedButtonTheme: OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        foregroundColor: primaryColor,
        side: const BorderSide(color: primaryColor),
        padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 24),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(buttonRadius),
        ),
        textStyle: GoogleFonts.poppins(
          fontWeight: FontWeight.w600,
          fontSize: 16,
        ),
      ),
    ),
    bottomNavigationBarTheme: BottomNavigationBarThemeData(
      backgroundColor: const Color(0xFF1E1E1E),
      selectedItemColor: primaryColor,
      unselectedItemColor: const Color(0xFF757575),
      elevation: 4,
      type: BottomNavigationBarType.fixed,
      selectedLabelStyle: GoogleFonts.poppins(fontSize: 12),
      unselectedLabelStyle: GoogleFonts.poppins(fontSize: 12),
    ),
    chipTheme: ChipThemeData(
      backgroundColor: const Color(0xFF424242),
      selectedColor: primaryColor,
      secondarySelectedColor: primaryColor,
      labelStyle: GoogleFonts.poppins(color: Colors.white),
      secondaryLabelStyle: GoogleFonts.poppins(color: Colors.white),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
      ),
    ),
  );
}
// lib/models/download_state.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

enum DownloadStatus {
  idle,
  fetching,
  downloading,
  completed,
  error,
}

class DownloadProgress {
  final DownloadStatus status;
  final String message;
  final double progress;
  final String? filePath;
  final String? error;

  const DownloadProgress({
    required this.status,
    required this.message,
    this.progress = 0.0,
    this.filePath,
    this.error,
  });

  DownloadProgress copyWith({
    DownloadStatus? status,
    String? message,
    double? progress,
    String? filePath,
    String? error,
  }) {
    return DownloadProgress(
      status: status ?? this.status,
      message: message ?? this.message,
      progress: progress ?? this.progress,
      filePath: filePath ?? this.filePath,
      error: error ?? this.error,
    );
  }
}

class DownloadState extends StateNotifier<DownloadProgress> {
  DownloadState()
      : super(const DownloadProgress(
          status: DownloadStatus.idle,
          message: 'Ready to download',
        ));

  void updateProgress(DownloadProgress progress) {
    state = progress;
  }

  void reset() {
    state = const DownloadProgress(
      status: DownloadStatus.idle,
      message: 'Ready to download',
    );
  }
}

// lib/providers/download_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/download_state.dart';
import '../services/download_service.dart';

final downloadProvider =
    StateNotifierProvider<DownloadState, DownloadProgress>((ref) {
  return DownloadState();
});

final downloadServiceProvider = Provider<DownloadService>((ref) {
  return DownloadService();
});

// lib/screens/home_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/download_provider.dart';
import '../models/download_state.dart';

class HomePage extends ConsumerWidget {
  const HomePage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final downloadProgress = ref.watch(downloadProvider);
    final TextEditingController urlController = TextEditingController();

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: const Text(
          'TikTok Downloader',
          style: TextStyle(fontWeight: FontWeight.w600),
        ),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black87,
        elevation: 0,
        centerTitle: true,
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: Column(
            children: [
              // Header Section
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(24),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(16),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.05),
                      blurRadius: 10,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: Column(
                  children: [
                    Icon(
                      Icons.video_library_outlined,
                      size: 48,
                      color: Colors.blue[600],
                    ),
                    const SizedBox(height: 12),
                    Text(
                      'Download TikTok Videos',
                      style: TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                        color: Colors.grey[800],
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Paste your TikTok URL below to download',
                      style: TextStyle(
                        fontSize: 14,
                        color: Colors.grey[600],
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 24),

              // URL Input Section
              Container(
                padding: const EdgeInsets.all(20),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(16),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.05),
                      blurRadius: 10,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    TextField(
                      controller: urlController,
                      decoration: InputDecoration(
                        labelText: 'TikTok URL',
                        hintText: 'https://www.tiktok.com/@username/video/...',
                        prefixIcon: Icon(Icons.link, color: Colors.blue[600]),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                          borderSide: BorderSide(color: Colors.grey[300]!),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                          borderSide: BorderSide(color: Colors.blue[600]!),
                        ),
                        filled: true,
                        fillColor: Colors.grey[50],
                      ),
                      maxLines: 2,
                      enabled: downloadProgress.status !=
                              DownloadStatus.downloading &&
                          downloadProgress.status != DownloadStatus.fetching,
                    ),
                    const SizedBox(height: 16),
                    SizedBox(
                      width: double.infinity,
                      height: 54,
                      child: ElevatedButton(
                        onPressed: _canDownload(downloadProgress)
                            ? () => _startDownload(
                                context, ref, urlController.text.trim())
                            : null,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.blue[600],
                          foregroundColor: Colors.white,
                          elevation: 0,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12),
                          ),
                          disabledBackgroundColor: Colors.grey[300],
                        ),
                        child: _buildButtonContent(downloadProgress),
                      ),
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 24),

              // Progress Section
              Expanded(
                child: Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(24),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(16),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 10,
                        offset: const Offset(0, 2),
                      ),
                    ],
                  ),
                  child: _buildProgressSection(
                      downloadProgress, ref, urlController),
                ),
              ),

              const SizedBox(height: 16),

              // Footer Note
              Text(
                'Please ensure you have permission to download the video and comply with TikTok\'s terms of service.',
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey[500],
                  fontStyle: FontStyle.italic,
                ),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildButtonContent(DownloadProgress progress) {
    switch (progress.status) {
      case DownloadStatus.fetching:
        return const Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
              ),
            ),
            SizedBox(width: 12),
            Text('Fetching...', style: TextStyle(fontSize: 16)),
          ],
        );
      case DownloadStatus.downloading:
        return Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                value: progress.progress,
                valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
              ),
            ),
            const SizedBox(width: 12),
            const Text('Downloading...', style: TextStyle(fontSize: 16)),
          ],
        );
      default:
        return const Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.download, size: 20),
            SizedBox(width: 8),
            Text('Download Video', style: TextStyle(fontSize: 16)),
          ],
        );
    }
  }

  Widget _buildProgressSection(DownloadProgress progress, WidgetRef ref,
      TextEditingController urlController) {
    switch (progress.status) {
      case DownloadStatus.idle:
        return Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.cloud_download_outlined,
              size: 64,
              color: Colors.grey[400],
            ),
            const SizedBox(height: 16),
            Text(
              'Ready to Download',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.w600,
                color: Colors.grey[600],
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Enter a TikTok URL above and tap download',
              style: TextStyle(
                fontSize: 14,
                color: Colors.grey[500],
              ),
              textAlign: TextAlign.center,
            ),
          ],
        );

      case DownloadStatus.fetching:
      case DownloadStatus.downloading:
        return Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.download,
              size: 64,
              color: Colors.blue[600],
            ),
            const SizedBox(height: 20),
            Text(
              progress.message,
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w600,
                color: Colors.blue[600],
              ),
            ),
            const SizedBox(height: 12),
            // LinearProgressIndicator(
            //   value: progress.progress,
            //   backgroundColor: Colors.grey[200],
            //   valueColor: AlwaysStoppedAnimation<Color>(Colors.blue[600]!),
            // ),
          ],
        );

      case DownloadStatus.completed:
        return Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.green[50],
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.check_circle,
                size: 64,
                color: Colors.green[600],
              ),
            ),
            const SizedBox(height: 20),
            Text(
              'Download Complete!',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                color: Colors.green[600],
              ),
            ),
            const SizedBox(height: 12),
            Text(
              'Video saved successfully',
              style: TextStyle(
                fontSize: 14,
                color: Colors.grey[600],
              ),
            ),
            if (progress.filePath != null) ...[
              const SizedBox(height: 8),
              Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                decoration: BoxDecoration(
                  color: Colors.grey[100],
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  _getFileName(progress.filePath!),
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey[700],
                    fontFamily: 'monospace',
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
            const SizedBox(height: 24),
            ElevatedButton.icon(
              onPressed: () {
                ref.read(downloadProvider.notifier).reset();
                urlController.clear();
              },
              icon: const Icon(Icons.refresh),
              label: const Text('Download Another'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.green[600],
                foregroundColor: Colors.white,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
            ),
          ],
        );

      case DownloadStatus.error:
        return Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.red[50],
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.error_outline,
                size: 64,
                color: Colors.red[600],
              ),
            ),
            const SizedBox(height: 20),
            Text(
              'Download Failed',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                color: Colors.red[600],
              ),
            ),
            const SizedBox(height: 12),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.red[50],
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.red[200]!),
              ),
              child: Text(
                progress.error ?? 'Unknown error occurred',
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.red[700],
                ),
                textAlign: TextAlign.center,
              ),
            ),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              onPressed: () {
                ref.read(downloadProvider.notifier).reset();
              },
              icon: const Icon(Icons.refresh),
              label: const Text('Try Again'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red[600],
                foregroundColor: Colors.white,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
            ),
          ],
        );
    }
  }

  bool _canDownload(DownloadProgress progress) {
    return progress.status == DownloadStatus.idle ||
        progress.status == DownloadStatus.completed ||
        progress.status == DownloadStatus.error;
  }

  void _startDownload(BuildContext context, WidgetRef ref, String url) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    if (url.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Please enter a TikTok URL',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: Colors.white,
            ),
          ),
          backgroundColor: const Color(0xFFFF9800), // Orange color
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
        ),
      );
      return;
    }

    if (!_isValidTikTokUrl(url)) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Please enter a valid TikTok URL',
            style: theme.textTheme.bodyMedium?.copyWith(
              color: Colors.white,
            ),
          ),
          backgroundColor: colorScheme.error,
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
        ),
      );
      return;
    }

    final downloadService = ref.read(downloadServiceProvider);
    downloadService.downloadVideo(url, (progress) {
      ref.read(downloadProvider.notifier).updateProgress(progress);
    });
  }

  bool _isValidTikTokUrl(String url) {
    return true; // Simplified validation
    // Uncomment for actual validation:
    // final tiktokRegex = RegExp(
    //   r'^https?://(www\.)?(tiktok\.com|vm\.tiktok\.com)',
    //   caseSensitive: false,
    // );
    // return tiktokRegex.hasMatch(url);
  }

  String _getFileName(String path) {
    return path.split('/').last;
  }
}
// lib/services/download_service.dart
import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:device_info_plus/device_info_plus.dart';
import '../models/download_state.dart';

class DownloadService {
  Future<void> downloadVideo(
      String tiktokUrl, void Function(DownloadProgress) updateProgress) async {
    try {
      // Step 1: Start fetching video details
      updateProgress(const DownloadProgress(
        status: DownloadStatus.fetching,
        message: 'Fetching video details...',
        progress: 0.1,
      ));

      print('DEBUG: Starting video download for URL: $tiktokUrl');

      // Call RapidAPI to get video details
      final apiResponse = await http.get(
        Uri.parse(
          'https://tiktok-download-without-watermark.p.rapidapi.com/analysis?url=$tiktokUrl&hd=1',
        ),
        headers: {
          'X-RapidAPI-Key':
              // '1b5bb662eamsh11110cdca03efa6p132479jsn76102bf53807',
              '58f8f3a841msha06b9e7847738bep132d02jsn2779b2309bc2',
          'X-RapidAPI-Host': 'tiktok-download-without-watermark.p.rapidapi.com',
        },
      );

      if (apiResponse.statusCode != 200) {
        throw Exception('Failed to fetch video details');
      }

      updateProgress(const DownloadProgress(
        status: DownloadStatus.fetching,
        message: 'Processing video URL...',
        progress: 0.3,
      ));

      final data = (apiResponse.body.isNotEmpty)
          ? jsonDecode(apiResponse.body)['data'] as Map<String, dynamic>
          : {};
      final videoUrl = data['hdplay'] ?? data['play'];

      if (videoUrl == null) {
        throw Exception('No downloadable video found');
      }

      // Step 2: Request storage permission
      updateProgress(const DownloadProgress(
        status: DownloadStatus.fetching,
        message: 'Checking permissions...',
        progress: 0.4,
      ));

      if (Platform.isAndroid) {
        bool hasPermission = await _requestStoragePermission();
        if (!hasPermission) {
          throw Exception('Storage permission required');
        }
      }

      // Step 3: Get download path
      updateProgress(const DownloadProgress(
        status: DownloadStatus.fetching,
        message: 'Preparing download...',
        progress: 0.5,
      ));

      Directory? dir;
      if (Platform.isAndroid) {
        try {
          dir = Directory('/storage/emulated/0/Download');
          if (!await dir.exists()) {
            dir = await getExternalStorageDirectory();
          }
        } catch (e) {
          dir = await getExternalStorageDirectory();
        }
      } else {
        dir = await getApplicationDocumentsDirectory();
      }

      if (dir == null) {
        throw Exception('Could not access storage');
      }

      final fileName =
          'tiktok_video_${DateTime.now().millisecondsSinceEpoch}.mp4';
      final filePath = '${dir.path}/$fileName';

      // Step 4: Download with progress tracking
      updateProgress(const DownloadProgress(
        status: DownloadStatus.downloading,
        message: 'Downloading video...',
        progress: 0.6,
      ));

      final request = http.Request('GET', Uri.parse(videoUrl));
      final response = await http.Client().send(request);

      if (response.statusCode == 200) {
        final file = File(filePath);
        final sink = file.openWrite();

        int downloaded = 0;
        final total = response.contentLength ?? 0;

        await for (var chunk in response.stream) {
          sink.add(chunk);
          downloaded += chunk.length;

          if (total > 0) {
            final progress = 0.6 + (downloaded / total) * 0.3;
            updateProgress(DownloadProgress(
              status: DownloadStatus.downloading,
              message:
                  'Downloading... ${((downloaded / total) * 100).toInt()}%',
              progress: progress,
            ));
          }
        }

        await sink.close();

        // Verify file creation
        if (await file.exists()) {
          updateProgress(DownloadProgress(
            status: DownloadStatus.completed,
            message: 'Download completed!',
            progress: 1.0,
            filePath: filePath,
          ));
        } else {
          throw Exception('Failed to save file');
        }
      } else {
        throw Exception('Download failed');
      }
    } catch (e) {
      print('DEBUG: Error occurred: $e');
      updateProgress(DownloadProgress(
        status: DownloadStatus.error,
        message: 'Download failed',
        error: e.toString(),
      ));
    }
  }

  Future<bool> _requestStoragePermission() async {
    try {
      final deviceInfo = DeviceInfoPlugin();
      final androidInfo = await deviceInfo.androidInfo;
      final sdkInt = androidInfo.version.sdkInt;

      if (sdkInt >= 33) {
        final manageStorageStatus =
            await Permission.manageExternalStorage.status;
        if (manageStorageStatus.isGranted) {
          return true;
        }
        final result = await Permission.manageExternalStorage.request();
        if (result.isGranted) {
          return true;
        }
        return true; // Use app-specific directory
      } else {
        final storageStatus = await Permission.storage.status;
        if (storageStatus.isGranted) {
          return true;
        }
        final result = await Permission.storage.request();
        return result.isGranted;
      }
    } catch (e) {
      print('DEBUG: Error requesting storage permission: $e');
      return false;
    }
  }
}
import 'package:downlista/core/theme/app_theme.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'screens/home_screen.dart';

void main() {
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeMode = ref.watch(themeModeProvider);
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'TikTok Downloader',
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: themeMode,
      home: const HomePage(),
    );
  }
}
